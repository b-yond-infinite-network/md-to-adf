<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>markdownParsing.js - Markdown to ADF translator</title>
    
    <meta name="description" content="Markdown to Atlassian Document Format translation" />
    
        <meta name="keywords" content="markdown, jira, atlassian, confluence, ADF" />
        <meta name="keyword" content="markdown, jira, atlassian, confluence, ADF" />
    
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    <h2><a href="index.html">Home</a></h2><h2><a href="https://github.com/b-yond-infinite-network/md-to-adf" target="_blank" class="menu-item" id="repository" >Github repo</a></h2><h3>Global</h3><ul><li><a href="global.html#accumulateLevelFromList">accumulateLevelFromList</a></li><li><a href="global.html#addTypeToNode">addTypeToNode</a></li><li><a href="global.html#attachItemNode">attachItemNode</a></li><li><a href="global.html#attachTextToNodeRaw">attachTextToNodeRaw</a></li><li><a href="global.html#attachTextToNodeSliceEmphasis">attachTextToNodeSliceEmphasis</a></li><li><a href="global.html#buildTreeFromLevelMap">buildTreeFromLevelMap</a></li><li><a href="global.html#buildTreeFromMarkdown">buildTreeFromMarkdown</a></li><li><a href="global.html#collapseBlockquote">collapseBlockquote</a></li><li><a href="global.html#collapseCodeBloc">collapseCodeBloc</a></li><li><a href="global.html#collapseParagraph">collapseParagraph</a></li><li><a href="global.html#convertDecorationLevelToMark">convertDecorationLevelToMark</a></li><li><a href="global.html#createLevelList">createLevelList</a></li><li><a href="global.html#fillADFNodesWithMarkdown">fillADFNodesWithMarkdown</a></li><li><a href="global.html#IRElement">IRElement</a></li><li><a href="global.html#IRTreeNode">IRTreeNode</a></li><li><a href="global.html#mapIRToLevels">mapIRToLevels</a></li><li><a href="global.html#matchBlockQuote">matchBlockQuote</a></li><li><a href="global.html#matchCodeBlock">matchCodeBlock</a></li><li><a href="global.html#matchDivider">matchDivider</a></li><li><a href="global.html#matchHeader">matchHeader</a></li><li><a href="global.html#matchList">matchList</a></li><li><a href="global.html#matchParagraph">matchParagraph</a></li><li><a href="global.html#parseMarkdownLinetoIR">parseMarkdownLinetoIR</a></li><li><a href="global.html#sliceEmoji">sliceEmoji</a></li><li><a href="global.html#sliceInLineCode">sliceInLineCode</a></li><li><a href="global.html#sliceLink">sliceLink</a></li><li><a href="global.html#sliceOneMatchFromRegexp">sliceOneMatchFromRegexp</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">markdownParsing.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**********************************************************************************************************************
 *
 *  Markdown Parser
 *
 *  @author bruno.morel@b-yond.com
 *---------------------------------------------------------------------------------------------------------------------
 *
 * This translate all markdown to an intermediate representation composed as an array with
 *  each item containing and object with the follow properties:
 *      adfType : 		the ADF type of the line (heading, paragraph, orderedList, ...
 *      textToEmphasis: the actuel text (if any) attached to the element
 *      typeParam:		any extra parameter for special types (language for codeBlock)
 *      nodeAttached: 	element to manage the special case of a codeBlock attached to a list
 *      textPosition: 	the actual start position of the text (used later for level identication)
 *
 **********************************************************************************************************************/

/**
 * @typedef {Object}  IRElement
 * @property {number} 		adfType 		- ADF type of the expression
 * @property {number} 		textPosition 	- the actual start of the text (adfType dependent)
 * @property {string} 		textToEmphasis 	- actual text of the element (adfType dependent)
 * @property {string} 		typeParam 		- extra parameters adfType dependent
 * @property {IRElement} 	nodeAttached 	- an attached code block to a list
 */

/**
 * Parse markdown into an Intermediate representation
 *
 * @param markdownLineTextWithTabs an array of markdown expression to process
 * @returns {IRElement}		an intermediate representation of the markdown element
 */
function parseMarkdownLinetoIR( markdownLineTextWithTabs ){
	//to simplify tab management we replace them with spaces
	const markdownLine = markdownLineTextWithTabs.replace( /\t/g, '    ' )
	
	//we try to match each line to match with a markdown expression
	// or we push an empty paragraph
	
	const headerNode = matchHeader( markdownLine )
	if( headerNode ) return headerNode
	
	const divider = matchDivider( markdownLine )
	if( divider ) return divider
	
	const listNode = matchList( markdownLine )
	if( listNode ) return listNode
	
	const blockQuoteNode = matchBlockQuote( markdownLine )
	if( blockQuoteNode ) return blockQuoteNode
	
	const codeBlockNode = matchCodeBlock( markdownLine )
	if( codeBlockNode ) return codeBlockNode
	
	const paragraphNode = matchParagraph( markdownLine )
	if( paragraphNode ) return paragraphNode
	
	//this is a line break then
	return { 	adfType : 		"paragraph",
		textToEmphasis: "",
		textPosition: 	markdownLine.length }
}

/**
 * Matching of the markdown header
 *
 * @param lineToMatch actual expression to match
 *
 * @returns {IRElement} | null if the expression doesn't match
 */
function matchHeader( lineToMatch ){
	const headerType = lineToMatch.match( /^(?&lt;headerNumber>[#]{1,6}) (?&lt;headerText>.*)$/i )
	if( headerType
		&amp;&amp; headerType.groups
		&amp;&amp; headerType.groups.headerNumber
		&amp;&amp; headerType.groups.headerText ){
		return { 	adfType : 		"heading",//adfRoot.heading( headerType.groups.headerNumber.length ),
			textToEmphasis: headerType.groups.headerText,
			typeParam:		headerType.groups.headerNumber.length,
			textPosition: 	0
		}
	}
	
	return null
}

/**
 * Matching of a markdown list
 *
 * @param lineToMatch actual expression to match
 *
 * @returns {IRElement} | null if the expression doesn't match
 */
function matchList( lineToMatch ){
	const list = lineToMatch.match( /^(?:[\s])*(?:[*\-+] |(?&lt;orderedNumber>[0-9]+)[.)] )+(?&lt;listText>.*)$/i )
	if( list
		&amp;&amp; list.groups
		&amp;&amp; list.groups.listText ){
		// adfDescription.bulletList( )
		// 			  .textItem(  )
		const textIsCodeBlock = matchCodeBlock( list.groups.listText )
		if( textIsCodeBlock )
			textIsCodeBlock.textPosition = lineToMatch.indexOf( list.groups.listText )
		
		return { 	adfType	: 		list.groups.orderedNumber
										? "orderedList"
										: "bulletList",
			typeParam:		list.groups.orderedNumber,
			textToEmphasis: textIsCodeBlock ? '': list.groups.listText,
			textPosition: 	lineToMatch.indexOf( list.groups.listText ) - 2,
			nodeAttached: 	textIsCodeBlock
		}
	}
	
	return null
}

/**
 * Match a markdown code block
 *
 * @param lineToMatch 	actual expression to match
 *
 * @returns {IRElement} | null if the expression doesn't match
 */
function matchCodeBlock( lineToMatch ){
	const codeBlock = lineToMatch.match( /^(?:[\s]*```)(?&lt;Language>[^\s]*)$/i )
	if( codeBlock
		&amp;&amp; codeBlock.groups ){
		
		return { 	adfType: 		"codeBlock",
			typeParam:		codeBlock.groups.Language,
			textPosition: 	lineToMatch.indexOf( '```' ),
			textToEmphasis: '' }
	}
	
	return null
}

/**
 * Match a markdown blockquote
 *
 * @param lineToMatch 	actual expression to match
 *
 * @returns {IRElement} | null if the expression doesn't match
 */
function matchBlockQuote( lineToMatch ){
	const blockquote = lineToMatch.match( /^(?:[\s])*> (?&lt;quoteText>.*)$/i )
	if( blockquote
		&amp;&amp; blockquote.groups
		&amp;&amp; blockquote.groups.quoteText ){
		
		return { 	adfType : 		"blockQuote",
			textToEmphasis: blockquote.groups.quoteText,
			textPosition: 	lineToMatch.indexOf( '> ' ) }
	}
	
	return null
}

/**
 * Match a markdown paragraph
 *
 * @param lineToMatch 	actual expression to match
 *
 * @returns {IRElement} | null if the expression doesn't match
 */
function matchParagraph( lineToMatch ){
	const paragraph = lineToMatch.match( /^(?:[\s]*)(?&lt;paragraphText>[^\n]+)$/ )
	if( paragraph
		&amp;&amp; paragraph.groups
		&amp;&amp; paragraph.groups.paragraphText ){
		return { 	adfType : 		"paragraph",
			textToEmphasis: paragraph.groups.paragraphText,
			textPosition: 	!paragraph.groups.paragraphText.match( /^(?:[\s]*)$/ )
							 ? lineToMatch.indexOf( paragraph.groups.paragraphText )
							 : lineToMatch.length }
	}
	
	return null
}

/**
 * Match a markdown divider
 *
 * @param lineToMatch 	actual expression to match
 *
 * @returns {IRElement} | null if the expression doesn't match
 */
function matchDivider( lineToMatch ){
	const divider = lineToMatch.match( /^(\s*-{3,}\s*|\s*\*{3,}\s*|\s*_{3,}\s*)$/ )
	if( divider ){
		return { 	adfType : 		"divider",
			textToEmphasis: '',
			textPosition: 	0 }
	}
	
	return null
}

module.exports = parseMarkdownLinetoIR
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.4</a> on Sat Sep 12 2020 15:26:51 GMT+0000 (Coordinated Universal Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/search.js" defer></script>



</body>
</html>
